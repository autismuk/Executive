<!DOCTYPE html><html><head><style>body { background:#333; color:#0F0; font-family:Arial,Verdana;} a { color:#0AA } h1 { color:#FF0; } h2 { color:#0FF } table,tr,td { color: #CCC; padding:4px;border:1px solid white; border-collapse:collapse; }</style></head><body>
<a name="Executive"></a>
<hr><h1>Executive</h1>
<p><h3>Extends Base</h3></p>
<p>The Executive Class is the main controller and storage system for objects. It also coordinates updates, timers and asynchronous messaging, which are built in. It uses ObjectLists regularly, which are a table consisting of a count, and a has of objects keyed on references.</p>
<p>Methods : <a href="#Executive_addLibraryObject"/>addLibraryObject</a>,<a href="#Executive_addMixinObject"/>addMixinObject</a>,<a href="#Executive_createClass"/>createClass</a>,<a href="#Executive_enterFrame"/>enterFrame</a>,<a href="#Executive_getGroup"/>getGroup</a>,<a href="#Executive_insert"/>insert</a>,<a href="#Executive_nameObject"/>nameObject</a>,<a href="#Executive_query"/>query</a>,<a href="#Executive_queueMessage"/>queueMessage</a>,<a href="#Executive_removeTimer"/>removeTimer</a></p><hr><a name="Executive_(constructor)"></a>
<a name="Executive_addLibraryObject"></a>
<h2>addLibraryObject(library,element,data)</h2>
<table>
<tr><td>library</td><td>string</td><td>LUA library to use (e.g. utils.controller)</td></tr>
<tr><td>element</td><td>string</td><td>Element with in library (optional)</td></tr>
<tr><td>data</td><td>table</td><td>Data to use in constructor (optional)</td></tr>
<tr><td>return</td><td>object</td><td>Library object instance.</td></tr>
</table>
<p>Add a library defined object. The library should return the class prototype or a table of prototypes (if element is used) An instance of this class is created using the supplied constructor data, it is added as a mixin object.</p>
<a name="Executive_addMixinObject"></a>
<h2>addMixinObject(object,data)</h2>
<table>
<tr><td>object</td><td>object</td><td>Mixin object to be decorated.</td></tr>
<tr><td>data</td><td>object</td><td>Optional data for the constructor call.</td></tr>
<tr><td>return</td><td>object</td><td>Object that was decorated.</td></tr>
</table>
<p>Add a mixin object to the system. Some objects may be created by modifying other classes via decoration, these will not inherit either the executive member or the member functions. This method decorates the mixin with both. Do not use this with game objects, which are added automatically by the constructor.</p>
<a name="Executive_addTag"></a>
<a name="Executive_addTimer"></a>
<a name="Executive_attach"></a>
<a name="Executive_createClass"></a>
<h2>createClass(baseClass)</h2>
<table>
<tr><td>baseClass</td><td>prototype</td><td>Base class to extend from (can be ignored, defaults to ExecutiveBaseClass)</td></tr>
<tr><td>return</td><td>object</td><td>Prototype for modification to produce a class/prototype</td></tr>
</table>
<p>This creates a class which can be used as a prototype - it is a replacement for the new() method. It returns an instance of the ExecutiveBaseClass to be modified.</p>
<a name="Executive_decorateMixinObject"></a>
<a name="Executive_delete"></a>
<a name="Executive_detach"></a>
<a name="Executive_enterFrame"></a>
<h2>enterFrame(eventData)</h2>
<table>
<tr><td>eventData</td><td>table</td><td>Event data.</td></tr>
</table>
<p>Handle enterFrame events and dispatch them via update, process messages and timers. Sends updates to object:onUpdate(deltaTime,deltaMS,systemTime), timer events to object:onTimer(tag,timerID) and messages to object:onMessage(from,message).</p>
<a name="Executive_fire"></a>
<a name="Executive_getGroup"></a>
<h2>getGroup()</h2>
<table>
<tr><td>return</td><td>display Group</td><td>executive's display group.</td></tr>
</table>
<p>Get the executive's display group.</p>
<a name="Executive_insert"></a>
<h2>insert(object)</h2>
<table>
<tr><td>object</td><td>display object</td><td>display object to be attached to the executive's group.</td></tr>
</table>
<p>Add a display object to the group.</p>
<a name="Executive_isGameObjectSubclass"></a>
<a name="Executive_nameObject"></a>
<h2>nameObject(name,object)</h2>
<table>
<tr><td>name</td><td>string</td><td>Name to give it in the object reference store</td></tr>
<tr><td>object</td><td>object</td><td>Object to attach to that reference.</td></tr>
</table>
<p>Name an object, storing a reference to it in executive.e</p>
<a name="Executive_process"></a>
<a name="Executive_query"></a>
<h2>query(tagList)</h2>
<table>
<tr><td>tagList</td><td>table</td><td>table of tags/strings which are required to be all satisfied.</td></tr>
<tr><td>return</td><td>objectlist</td><td>table with 2 values, dictionary of objects => objects and count of hits.</td></tr>
</table>
<p>Query the object database for all objects with all the listed tags.</p>
<a name="Executive_queueMessage"></a>
<h2>queueMessage(recipient,sender,message,delayTime)</h2>
<table>
<tr><td>recipient</td><td>object/string</td><td>object or query for recipients of message</td></tr>
<tr><td>sender</td><td>object</td><td>object sending the message</td></tr>
<tr><td>message</td><td>table</td><td>message body.</td></tr>
<tr><td>delayTime</td><td>number</td><td>time message is to be delayed in ms.</td></tr>
</table>
<p>Queue a message to be sent to object or objects.</p>
<a name="Executive_removeTag"></a>
<a name="Executive_removeTimer"></a>
<h2>removeTimer(timerID)</h2>
<table>
<tr><td>timerID</td><td>number</td><td>ID of timer to remove</td></tr>
</table>
<p>Remove a timer with the given timer ID</p>
<a name="Executive_split"></a>
<a name="Executive_tableSize"></a>
<a name="ExecutiveBaseClass"></a>
<hr><h1>ExecutiveBaseClass</h1>
<p><h3>Extends Base</h3></p>
<p></p>
<p>Methods : <a href="#ExecutiveBaseClass_addRepeatingTimer"/>addRepeatingTimer</a>,<a href="#ExecutiveBaseClass_addSingleTimer"/>addSingleTimer</a>,<a href="#ExecutiveBaseClass_addTimer"/>addTimer</a>,<a href="#ExecutiveBaseClass_constructor"/>constructor</a>,<a href="#ExecutiveBaseClass_delete"/>delete</a>,<a href="#ExecutiveBaseClass_destructor"/>destructor</a>,<a href="#ExecutiveBaseClass_getExecutive"/>getExecutive</a>,<a href="#ExecutiveBaseClass_insert"/>insert</a>,<a href="#ExecutiveBaseClass_isAlive"/>isAlive</a>,<a href="#ExecutiveBaseClass_name"/>name</a>,<a href="#ExecutiveBaseClass_query"/>query</a>,<a href="#ExecutiveBaseClass_removeTimer"/>removeTimer</a>,<a href="#ExecutiveBaseClass_sendMessage"/>sendMessage</a>,<a href="#ExecutiveBaseClass_tag"/>tag</a></p><hr><a name="ExecutiveBaseClass_(constructor)"></a>
<a name="ExecutiveBaseClass_addRepeatingTimer"></a>
<h2>addRepeatingTimer(delay,tag,target)</h2>
<table>
<tr><td>delay</td><td>number</td><td>Timer delay in milliseconds.</td></tr>
<tr><td>tag</td><td>string</td><td>Identifying tag for timer (optional)</td></tr>
<tr><td>target</td><td>object</td><td>Object to receive timer (defaults to self)</td></tr>
<tr><td>return</td><td>number</td><td>Timer ID</td></tr>
</table>
<p>Fire a timer continuously until stopped.</p>
<a name="ExecutiveBaseClass_addSingleTimer"></a>
<h2>addSingleTimer(delay,tag,target)</h2>
<table>
<tr><td>delay</td><td>number</td><td>Timer delay in milliseconds.</td></tr>
<tr><td>tag</td><td>string</td><td>Identifying tag for timer (optional)</td></tr>
<tr><td>target</td><td>object</td><td>Object to receive timer (defaults to self)</td></tr>
<tr><td>return</td><td>number</td><td>Timer ID</td></tr>
</table>
<p>Fire a timer once only.</p>
<a name="ExecutiveBaseClass_addTimer"></a>
<h2>addTimer(delay,repeatCount,tag,target)</h2>
<table>
<tr><td>delay</td><td>number</td><td>Timer delay in milliseconds.</td></tr>
<tr><td>repeatCount</td><td>number</td><td>Number of repeats (1 +, -1 = continuous)</td></tr>
<tr><td>tag</td><td>string</td><td>Identifying tag for timer (optional)</td></tr>
<tr><td>target</td><td>object</td><td>Object to receive timer (defaults to self)</td></tr>
<tr><td>return</td><td>number</td><td>Timer ID</td></tr>
</table>
<p>Fire a timer a specific number of times (including until stopped.)</p>
<a name="ExecutiveBaseClass_constructor"></a>
<h2>constructor(data)</h2>
<table>
<tr><td>data</td><td>table</td><td>Data for constructor</td></tr>
</table>
<p>Constructor for game object. In the base object this is a dummy.</p>
<a name="ExecutiveBaseClass_delete"></a>
<h2>delete()</h2>
<p>Delete object from game. This calls the destructor and disconnects the object from the executive</p>
<a name="ExecutiveBaseClass_destructor"></a>
<h2>destructor()</h2>
<p>Destructor for game object. In the base object this is a dummy.</p>
<a name="ExecutiveBaseClass_getExecutive"></a>
<h2>getExecutive()</h2>
<table>
<tr><td>return</td><td>executive</td><td>Executive object controlling this object</td></tr>
</table>
<p>Get the current executive reference</p>
<a name="ExecutiveBaseClass_insert"></a>
<h2>insert(...)</h2>
<table>
<tr><td>...</td><td></td><td></td></tr>
</table>
<p>Add a display object to the group associated with this object's executive.</p>
<a name="ExecutiveBaseClass_isAlive"></a>
<h2>isAlive()</h2>
<table>
<tr><td>return</td><td>boolean</td><td>true if object is still alive.</td></tr>
</table>
<p>Check to see if an object is still alive.</p>
<a name="ExecutiveBaseClass_name"></a>
<h2>name(name)</h2>
<table>
<tr><td>name</td><td>string</td><td>Name to call it.</td></tr>
</table>
<p>Name the current object as a reference in executive.e</p>
<a name="ExecutiveBaseClass_query"></a>
<h2>query(tagList)</h2>
<table>
<tr><td>tagList</td><td>string</td><td>list of tags, seperated by commas.</td></tr>
<tr><td>return</td><td>objectlist</td><td>table with 2 values, dictionary of objects => objects and count of hits.</td></tr>
</table>
<p>Query the object database for all objects with all the listed tags.</p>
<a name="ExecutiveBaseClass_removeTimer"></a>
<h2>removeTimer(timerID)</h2>
<table>
<tr><td>timerID</td><td>number</td><td>ID of timer to remove</td></tr>
</table>
<p>Remove a timer with the given timer ID</p>
<a name="ExecutiveBaseClass_sendMessage"></a>
<h2>sendMessage(target,contents,delay)</h2>
<table>
<tr><td>target</td><td>query/object</td><td>Object or query to send the message to.</td></tr>
<tr><td>contents</td><td>table</td><td>Message contents.</td></tr>
<tr><td>delay</td><td>number</td><td>Message delay time in milliseconds (defaults to immediately)</td></tr>
</table>
<p>Send a message after an optional display. Note that message sending is asynchronous.</p>
<a name="ExecutiveBaseClass_tag"></a>
<h2>tag(tagChanges)</h2>
<table>
<tr><td>tagChanges</td><td>string</td><td>tags to add and remove from an object.</td></tr>
</table>
<p>Add or remove tags from an object. The parameter is a sequence of tags, seperated by commas, that may be prefixed by '+' or '-' to add or remove a tag. The default is to add.</p>
<a name="ExecutiveFactory"></a>
<hr><h1>ExecutiveFactory</h1>
<p><h3>Extends Base</h3></p>
<p>This is the base class for the executive factory, which is a factory class which creates and manages executives, each executive being a 'scene' in the game.</p>
<p>Methods : <a href="#ExecutiveFactory_clean"/>clean</a>,<a href="#ExecutiveFactory_close"/>close</a>,<a href="#ExecutiveFactory_constructor"/>constructor</a>,<a href="#ExecutiveFactory_destructor"/>destructor</a>,<a href="#ExecutiveFactory_getExecutive"/>getExecutive</a>,<a href="#ExecutiveFactory_instantiate"/>instantiate</a>,<a href="#ExecutiveFactory_open"/>open</a>,<a href="#ExecutiveFactory_postClose"/>postClose</a>,<a href="#ExecutiveFactory_preOpen"/>preOpen</a></p><hr><a name="ExecutiveFactory_clean"></a>
<h2>clean()</h2>
<p>The clean() method allows garbage collection. If an app is running low on memory, it can call this on all scenes but the current one. It calls the destructor to free up any resources. If they are needed again, they will be reloaded.</p>
<a name="ExecutiveFactory_close"></a>
<h2>close()</h2>
<p>Close phase. When the running executive has decided that this scene is over, and it is going to end, this method will be called once the Game's FSM has decided to switch to another scene. It normally should not be touched - it is usually the responsibility of the executive to stop itself from running.</p>
<a name="ExecutiveFactory_constructor"></a>
<h2>constructor()</h2>
<p>The constructor loads long term resources that belong to this executive. It is called when necessary.</p>
<a name="ExecutiveFactory_destructor"></a>
<h2>destructor()</h2>
<p>The detructor frees long term resources that belong to this executive.</p>
<a name="ExecutiveFactory_getExecutive"></a>
<h2>getExecutive()</h2>
<table>
<tr><td>return</td><td>Executive</td><td>Executive instance.</td></tr>
</table>
<p>Get the current executive for this factory, creating it if necessary.</p>
<a name="ExecutiveFactory_instantiate"></a>
<h2>instantiate()</h2>
<p>First call the constructor for long term resources if this hasn't already been done. Check to see if the object has been instantiated, if not create the executive</p>
<a name="ExecutiveFactory_open"></a>
<h2>open()</h2>
<p>Open phase. This is called after the transition to this scene has finished, and should start the actual game.</p>
<a name="ExecutiveFactory_postClose"></a>
<h2>postClose()</h2>
<p>This is called after the transition to the next screen has occurred, and should normally not be touched - it removes the executive object. thus removing all the attached objects.</p>
<a name="ExecutiveFactory_preOpen"></a>
<h2>preOpen()</h2>
<p>Pre-open phase. This method will be called when the scene is switched to, but before the transition has started. This should create objects but not activate them, so the game screen is up but not actually doing anything, so it can be transitioned in.</p>
<a name="FSM"></a>
<hr><h1>FSM</h1>
<p><h3>Extends Base</h3></p>
<p>Four way controller class</p>
<p>Methods : <a href="#FSM_addState"/>addState</a>,<a href="#FSM_constructor"/>constructor</a>,<a href="#FSM_event"/>event</a>,<a href="#FSM_getState"/>getState</a>,<a href="#FSM_start"/>start</a></p><hr><a name="FSM_addState"></a>
<h2>addState(stateName,statedef)</h2>
<table>
<tr><td>stateName</td><td>string</td><td>Text name of state</td></tr>
<tr><td>statedef</td><td>table</td><td>Table of events for that state.</td></tr>
</table>
<p>Add a state to the FSM</p>
<a name="FSM_announce"></a>
<a name="FSM_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td>table</td><td>contains states, built of events, and listener and firstState items.</td></tr>
</table>
<p>Create a new finite state machine.</p>
<a name="FSM_destructor"></a>
<a name="FSM_event"></a>
<h2>event(event)</h2>
<table>
<tr><td>event</td><td>string</td><td>event occurring</td></tr>
</table>
<p>Send an event to the FSM, causing a possible change of state.</p>
<a name="FSM_getState"></a>
<h2>getState()</h2>
<table>
<tr><td>return</td><td>string</td><td>current state.</td></tr>
</table>
<p>Get the current state</p>
<a name="FSM_start"></a>
<h2>start(override)</h2>
<table>
<tr><td>override</td><td>string</td><td>Optional override for start state.</td></tr>
<tr><td>return</td><td>FSM</td><td>Self, allowing chaining.</td></tr>
</table>
<p>Start an FSM, validating it first</p>
<a name="Game"></a>
<hr><h1>Game</h1>
<p><h3>Extends Executive</h3></p>
<p></p>
<p>Methods : <a href="#Game_(constructor)"/>(constructor)</a>,<a href="#Executive_addLibraryObject"/><i>addLibraryObject</i></a>,<a href="#Executive_addMixinObject"/><i>addMixinObject</i></a>,<a href="#Game_addState"/>addState</a>,<a href="#Executive_createClass"/><i>createClass</i></a>,<a href="#Executive_enterFrame"/><i>enterFrame</i></a>,<a href="#Game_event"/>event</a>,<a href="#Executive_getGroup"/><i>getGroup</i></a>,<a href="#Game_getState"/>getState</a>,<a href="#Executive_insert"/><i>insert</i></a>,<a href="#Executive_nameObject"/><i>nameObject</i></a>,<a href="#Executive_query"/><i>query</i></a>,<a href="#Executive_queueMessage"/><i>queueMessage</i></a>,<a href="#Executive_removeTimer"/><i>removeTimer</i></a>,<a href="#Game_start"/>start</a></p><hr><a name="Game_(constructor)"></a>
<h2>(constructor)()</h2>
<p>Instantiate the game class.</p>
<a name="Game_addState"></a>
<h2>addState(stateName,executiveFactoryInstance,stateDefinition)</h2>
<table>
<tr><td>stateName</td><td>string</td><td>Name of state to add.</td></tr>
<tr><td>executiveFactoryInstance</td><td>factoryInstance</td><td>Executive Factory instance associated with this state.</td></tr>
<tr><td>stateDefinition</td><td>stateDef</td><td>State definition, events -> new states. Also contains transaction information.</td></tr>
</table>
<p>Add a new state to the Game's FSM. Each FSM state has an associated executiveFactory object which manages its executive class.</p>
<a name="Game_event"></a>
<h2>event(eventName)</h2>
<table>
<tr><td>eventName</td><td>string</td><td>Event name to apply.</td></tr>
</table>
<p>Apply an event to the Game's FSM.</p>
<a name="Game_getState"></a>
<h2>getState()</h2>
<table>
<tr><td>return</td><td>string</td><td>state name</td></tr>
</table>
<p>Return the current state</p>
<a name="Game_start"></a>
<h2>start(overrideState)</h2>
<table>
<tr><td>overrideState</td><td>string</td><td>State to go to first, can override that in the FSM for debugging.</td></tr>
</table>
<p>Start the game.</p>
<a name="GameManagerClass"></a>
<hr><h1>GameManagerClass</h1>
<p><h3>Extends ExecutiveBaseClass</h3></p>
<p></p>
<p>Methods : <a href="#ExecutiveBaseClass_addRepeatingTimer"/><i>addRepeatingTimer</i></a>,<a href="#ExecutiveBaseClass_addSingleTimer"/><i>addSingleTimer</i></a>,<a href="#ExecutiveBaseClass_addTimer"/><i>addTimer</i></a>,<a href="#GameManagerClass_constructor"/>constructor</a>,<a href="#ExecutiveBaseClass_delete"/><i>delete</i></a>,<a href="#ExecutiveBaseClass_destructor"/><i>destructor</i></a>,<a href="#ExecutiveBaseClass_getExecutive"/><i>getExecutive</i></a>,<a href="#ExecutiveBaseClass_insert"/><i>insert</i></a>,<a href="#ExecutiveBaseClass_isAlive"/><i>isAlive</i></a>,<a href="#GameManagerClass_memory"/>memory</a>,<a href="#ExecutiveBaseClass_name"/><i>name</i></a>,<a href="#GameManagerClass_onMessage"/>onMessage</a>,<a href="#ExecutiveBaseClass_query"/><i>query</i></a>,<a href="#ExecutiveBaseClass_removeTimer"/><i>removeTimer</i></a>,<a href="#ExecutiveBaseClass_sendMessage"/><i>sendMessage</i></a>,<a href="#ExecutiveBaseClass_tag"/><i>tag</i></a>,<a href="#GameManagerClass_transitionCompleted"/>transitionCompleted</a></p><hr><a name="GameManagerClass_constructor"></a>
<h2>constructor(info)</h2>
<table>
<tr><td>info</td><td></td><td></td></tr>
</table>
<p>Constructor for Game manager.</p>
<a name="GameManagerClass_memory"></a>
<h2>memory()</h2>
<p>Put memory information as a little text string at the screen top.</p>
<a name="GameManagerClass_onMessage"></a>
<h2>onMessage(sender,message)</h2>
<table>
<tr><td>sender</td><td>object</td><td>where it came from.</td></tr>
<tr><td>message</td><td>message</td><td>executive message describing fsm state changes.</td></tr>
</table>
<p>Game Manager message handler. Receives state changes from the game's FSM.</p>
<a name="GameManagerClass_transitionCompleted"></a>
<h2>transitionCompleted()</h2>
<p>This method is called by the Transaction Manager library when a transaction is completed.</p>
<a name="Object"></a>
<hr><h1>Object</h1>
<p><h3>Extends baseClass</h3></p>
<p></p>
<p>Methods : </p><hr><a name="ObjectManagerClass"></a>
<hr><h1>ObjectManagerClass</h1>
<p><h3>Extends ExecutiveBaseClass</h3></p>
<p></p>
<p>Methods : <a href="#ObjectManagerClass_addFactoryObject"/>addFactoryObject</a>,<a href="#ExecutiveBaseClass_addRepeatingTimer"/><i>addRepeatingTimer</i></a>,<a href="#ExecutiveBaseClass_addSingleTimer"/><i>addSingleTimer</i></a>,<a href="#ExecutiveBaseClass_addTimer"/><i>addTimer</i></a>,<a href="#ObjectManagerClass_constructor"/>constructor</a>,<a href="#ExecutiveBaseClass_delete"/><i>delete</i></a>,<a href="#ObjectManagerClass_destructor"/>destructor</a>,<a href="#ExecutiveBaseClass_getExecutive"/><i>getExecutive</i></a>,<a href="#ObjectManagerClass_getFactoryInstance"/>getFactoryInstance</a>,<a href="#ExecutiveBaseClass_insert"/><i>insert</i></a>,<a href="#ExecutiveBaseClass_isAlive"/><i>isAlive</i></a>,<a href="#ExecutiveBaseClass_name"/><i>name</i></a>,<a href="#ExecutiveBaseClass_query"/><i>query</i></a>,<a href="#ExecutiveBaseClass_removeTimer"/><i>removeTimer</i></a>,<a href="#ExecutiveBaseClass_sendMessage"/><i>sendMessage</i></a>,<a href="#ExecutiveBaseClass_tag"/><i>tag</i></a></p><hr><a name="ObjectManagerClass_addFactoryObject"></a>
<h2>addFactoryObject(state,factoryInstance)</h2>
<table>
<tr><td>state</td><td>string</td><td>Name of state</td></tr>
<tr><td>factoryInstance</td><td>factory</td><td>instance of executive factory.</td></tr>
</table>
<p>Add a factory instance attached to a given state name.</p>
<a name="ObjectManagerClass_constructor"></a>
<h2>constructor()</h2>
<p>Create an empty object mananger class.</p>
<a name="ObjectManagerClass_destructor"></a>
<h2>destructor()</h2>
<p>Tidy up factory instances.</p>
<a name="ObjectManagerClass_getFactoryInstance"></a>
<h2>getFactoryInstance(state)</h2>
<table>
<tr><td>state</td><td>string</td><td>Name of state</td></tr>
<tr><td>return</td><td>factory</td><td>Factory instance associated with it.</td></tr>
</table>
<p>Retrieve factory instance for given named state.</p>
<hr><p><i>LUA Autodoc by Paul Robson 2014</i></p><hr></body></html>
